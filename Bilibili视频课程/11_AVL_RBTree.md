- 有序表的各种实现方式（红黑树、AVL、SB、跳表）
- 平衡二叉树AVL

  ```
  1. 任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树,查找、插入和删除在平均和最坏情况下的时间复杂度都是O(logN)
  2. 假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。
  3. 某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子,节点的平衡因子只能取 0 、1 或者 -1 
  4. 最小失衡子树：在新插入的结点向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。
  ```

- 树的左旋和右旋：平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的。根据旋转的方向有两种处理方式，左旋 与 右旋

  ```
  左旋：插入一个大于该子树所有节点的值（1）节点的右孩子替代此节点位置 （2）右孩子的左子树变为该节点的右子树 （3）节点本身变为右孩子的左子树
  右旋：插入一个小于该子树所有节点的值（1）节点的左孩子代表此节点 （2）节点的左孩子的右子树变为节点的左子树 （3）将此节点作为左孩子节点的右子树。
  ```

- AVL树插入节点的情况分为以下四种：

  ```
  LL: 在 A 的左子树根节点的左子树上插入节点而破坏平衡 | 需要右旋转
  RR: 在 A 的右子树根节点的右子树上插入节点而破坏平衡 | 需要左旋转
  LR | 在A的左子树根节点的右子树上插入节点而破坏平衡  | 先左旋后右旋 
  RL | 在A的右子树根节点的左子树上插入节点而破坏平衡  | 先右旋后左旋
  ```

- AVL树的四种删除节点方式： AVL 树在删除节点后需要重新检查平衡性并修正，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点

  ```
  （1）删除叶子节点 
  （2）删除的节点只有左子树 
  （3）删除的节点只有右子树 
  （4）删除的节点既有左子树又有右子树
  1. 如果直接删除成功且仍为二叉查找树（删除的节点只有左子树用左子树节点替代），则是前三种情况。则依次向上检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。
  注意删除右子树的节点相当于在左子树上插入新的节点
  2. 被删的结点既有左子树又有右子树：找到左子树最大值或右子树最小值进行替换，然后进行调整
  ```

- SB树(Size Blanced Tree，\基础提升班\2.1 课前预习（课件+源码）\提升班第二课代码)

  ```
  当前节点子树的大小，要小于兄弟节点的大小
  ```

- SkipList跳表：并行效率比红黑树高，删除节点快速

  ```
  1. AVL树有着严格的O(logN)的查询效率，但是由于插入过程中可能需要多次旋转，导致插入效率较低，因而才有了在工程界更加实用的红黑树。
  红黑树有一个问题就是在并发环境下使用不方便,需要锁住更多的节点，从而降低了并发性能
  2. 跳表就是在普通单向链表的基础上增加了一些索引，而且这些索引是分层的，从而可以快速地查的到数据。
  分层链表查找和删除数据
  ```

  ​	![img](https://pic2.zhimg.com/80/v2-a78099a1347aa36d2599a6d78849a4ad_720w.jpg)

- 红黑树

  ```
  1. 平衡树要求每个节点的左子树和右子树的高度差至多等于1，导致每次进行插入/删除节点的时候，都需要通过左旋和右旋来进行调整，不适用于那种插入、删除很频繁的场景
  2. 红黑树具有如下特点：不需要频繁着调整，是一种不大严格的平衡树
  （1）具有二叉查找树的特点。
  （2）根节点是黑色的；每个节点要么是黑色，要么是红色，每个红色结点的两个子结点一定都是黑色
  （3）每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。
  （4）每个红色结点的两个子结点一定都是黑色，不会有连续的红色节点
  （5）黑色完美平衡：每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。（如果一个结点存在黑子结点，那么该结点肯定有两个子结点）
  
  红黑树的查找效率不如AVL，但是插入和删除效率更高，性能稳定
  1. 查找和平衡二叉树一样
  2. 变色和旋转：左旋和右旋
  3. 插入：插入节点的颜色是红色。插入后需要修复
  4. 删除：删除红色节点和AVL近似，删除黑色节点
  ```

